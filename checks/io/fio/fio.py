# Copyright 2025 Canonical Ltd.
# See LICENSE file for licensing details.

"""Flexible I/O Tester checks."""

import json
import os

import reframe as rfm
import reframe.utility.sanity as sn


class build_fio(rfm.CompileOnlyRegressionTest):
    """Build Flexible I/O Tester source code."""

    descr = "Build Flexible I/O Tester"
    sourcesdir = "https://github.com/axboe/fio.git"
    version = variable(str, value="fio-3.38")
    prebuild_cmds = [f"git checkout {version}"]
    # Actually uses a custom build system influenced by Autotools
    build_system = "Autotools"

    @run_before("compile")
    def prepare_build(self):
        """Add build system options."""
        # Custom build script fails with default configure line generated by ReFrame, e.g.
        #   ./configure CC="cc"
        # fails with:
        #   Bad option CC=cc
        # Fix by overriding build system flags here.
        self.build_system.flags_from_environ = False
        # Build uses -march=native by default. Set --disable-native here to avoid illegal
        # instruction errors when running on compute nodes of different arch.
        self.build_system.config_opts = ["--cc=cc", "--disable-native"]


class fio_check_base(rfm.RunOnlyRegressionTest):
    """Base class for Flexible I/O Tester tests."""

    descr = "fio speed test"
    valid_systems = ["*"]
    valid_prog_environs = ["builtin"]
    fio_binary = fixture(build_fio, scope="environment")

    # block_file_size = parameter([("4K","128M"), ("4M","2G")])
    block_file_size = ("4M", "2G")
    mode = parameter(["read", "write"])
    directory_prefix = None

    # Job directives
    num_tasks = 1
    num_tasks_per_node = 1
    num_cpus_per_task = 2
    time_limit = "10m"

    @run_before("run")
    def set_run_commands(self):
        """Set job script commands."""
        self.executable = os.path.join(self.fio_binary.stagedir, "fio")
        # TODO: investigate options for clearing cache. "echo 3 > /proc/sys/vm/drop_caches" needs root.
        self.prerun_cmds = [
            f"WORKING_DIR=$(mktemp -d -p {self.directory_prefix})",
            "sync",
        ]

        block_size, file_size = self.block_file_size
        self.executable_opts = [
            f"--name={self.mode}_{file_size}",
            '--directory="$WORKING_DIR"',
            "--direct=1",
            f"--size={file_size}",
            f"--bs={block_size}",
            f"--rw={self.mode}",
            f"--numjobs={self.num_cpus_per_task}",
            "--group_reporting",
            "--runtime=30",
            "--output-format=json",
        ]

        self.postrun_cmds = ['rm -rf "$WORKING_DIR"']

    @sanity_function
    def validate(self):
        """Validate output."""
        return sn.assert_found("fio", self.stdout)

    def _extract_metric(self, metric):
        """Extract given metric from job output."""
        output_path = sn.evaluate(self.stdout)
        with open(output_path, "r") as output_file:
            data = json.load(output_file)
        return data["jobs"][0][self.mode][metric]

    @performance_function("MiB/s")
    def extract_bandwidth(self):
        """Extract bandwidth from job output."""
        # json output format gives bandwidth in KiB/s. Convert to MiB/s.
        return self._extract_metric("bw") / 1024.0

    @performance_function("IOPS")
    def extract_iops(self):
        """Extract IOPS from job output."""
        return self._extract_metric("iops")


@rfm.simple_test
class fio_check_home(fio_check_base):
    """FIO home directory checks."""

    directory_prefix = f"{os.environ['HOME']}/"


@rfm.simple_test
class fio_check_nfs(fio_check_base):
    """FIO NFS checks."""

    directory_prefix = "/nfs/home/"
